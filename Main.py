import tkinter as tk
from tkinter import scrolledtext, messagebox, filedialog
import nmap
import threading
from reportlab.pdfgen import canvas
import requests  # Add the requests library for API calls
import json

# Initialize the main Tkinter window
app = tk.Tk()
app.title("Vulnerability Assessment Tool")
app.geometry("800x600")

# Your Google Custom Search API Key and Search Engine ID
GOOGLE_API_KEY = "YOUR_GOOGLE_API_KEY"  # Add your Google API key here
SEARCH_ENGINE_ID = "YOUR_SEARCH_ENGINE_ID"  # Add your Search Engine ID here

# Nmap scanning options based on user's choice
SCAN_OPTIONS = {
    "Fast Scan": "-F -O -sV -sC --fuzzy --version-intensity 5 --script=default --data-length 50 --ttl 64",
    "Basic Scan": "-O -sV -sC --top-ports 1000 --fuzzy --version-intensity 5 --data-length 50 --ttl 64",
    "Full Scan (TCP only)": "-p- -O -sV -sC --fuzzy --version-intensity 5 --data-length 50 --ttl 64",
    "Full Scan (TCP & UDP)": "-p- -sU --top-ports 1000 -O -sV -sC --fuzzy --version-intensity 5 --data-length 50 --ttl 64"
}

# Function to search for vulnerabilities using Google Custom Search API
def search_vulnerability(service_name, version):
    query = f"{service_name} {version} vulnerability"
    url = f"https://www.googleapis.com/customsearch/v1?key={GOOGLE_API_KEY}&cx={SEARCH_ENGINE_ID}&q={query}"

    try:
        response = requests.get(url)
        if response.status_code == 200:
            items = response.json().get('items', [])
            if items:
                results = ""
                for item in items:
                    results += f"Title: {item['title']}\nLink: {item['link']}\nSnippet: {item['snippet']}\n\n"
                return results if results else "No vulnerabilities found."
            else:
                return "No results found."
        else:
            return f"Error: Received status code {response.status_code} with response: {response.text}"
    except Exception as e:
        return f"Error while fetching vulnerabilities: {e}"

# Function to run the advanced Nmap scan with selected options
def run_advanced_scan(target_ip, scan_type):
    scanner = nmap.PortScanner()
    try:
        arguments = SCAN_OPTIONS[scan_type]
        scan_data = scanner.scan(target_ip, arguments=arguments)
        return scan_data, None
    except nmap.PortScannerError as e:
        return None, f"Nmap Error: {e}"
    except Exception as e:
        return None, f"General Error: {e}"

# Function to start the scan and process the results
def start_scan():
    target_ip = target_entry.get()
    scan_type = scan_option.get()
    
    if not target_ip:
        messagebox.showerror("Input Error", "Please enter a valid target IP or hostname.")
        return

    scan_button.config(state=tk.DISABLED)
    log_text.insert(tk.END, f"[*] Starting {scan_type} on {target_ip}...\n")

    def run_scan_thread():
        try:
            scan_data, error = run_advanced_scan(target_ip, scan_type)
            if error:
                log_text.insert(tk.END, f"[!] Scan failed: {error}\n")
                scan_button.config(state=tk.NORMAL)
                return

            log_text.insert(tk.END, "[*] Scan completed. Analyzing results...\n")

            report_content = ""
            for host in scan_data['scan']:
                report_content += f"\nHost: {host}\n"
                log_text.insert(tk.END, f"\nHost: {host}\n")
                for proto in scan_data['scan'][host]:
                    if proto == 'tcp' or proto == 'udp':
                        for port in scan_data['scan'][host][proto]:
                            port_info = scan_data['scan'][host][proto][port]
                            service = port_info['name']
                            version = port_info.get('version', 'N/A')
                            report_line = f"Port: {port}, State: {port_info['state']}, Service: {service}, Version: {version}\n"
                            report_content += report_line
                            log_text.insert(tk.END, report_line)

                            # Lookup vulnerabilities and provide remediation recommendations
                            vulnerability_info = search_vulnerability(service, version)
                            log_text.insert(tk.END, f"Vulnerabilities for {service} {version}:\n{vulnerability_info}\n")

            log_text.insert(tk.END, "[*] Scan finished.\n")
            app.report_content = report_content  # Save the report content
        except Exception as e:
            log_text.insert(tk.END, f"[!] Error during scan: {e}\n")
        finally:
            scan_button.config(state=tk.NORMAL)

    scan_thread = threading.Thread(target=run_scan_thread)
    scan_thread.start()

# Function to save the report content as a text file
def save_to_text(report_content):
    if not report_content:
        messagebox.showwarning("Save Error", "No report content to save.")
        return

    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
    if file_path:
        with open(file_path, "w") as file:
            file.write(report_content)
        messagebox.showinfo("Save Report", f"Report saved to {file_path}")

# Function to save the report content as a PDF file
def save_to_pdf(report_content):
    if not report_content:
        messagebox.showwarning("Save Error", "No report content to save.")
        return

    file_path = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF files", "*.pdf")])
    if file_path:
        c = canvas.Canvas(file_path)
        lines = report_content.splitlines()
        y_position = 800  # Start position for the text in PDF
        for line in lines:
            if y_position <= 100:
                c.showPage()
                y_position = 800
            c.drawString(100, y_position, line)
            y_position -= 15
        c.save()
        messagebox.showinfo("Save Report", f"PDF report saved to {file_path}")

# Setting up the GUI elements
tk.Label(app, text="Target IP/Hostname:").grid(row=0, column=0, padx=10, pady=10)
target_entry = tk.Entry(app, width=50)
target_entry.grid(row=0, column=1, padx=10, pady=10)

tk.Label(app, text="Select Scan Type:").grid(row=1, column=0, padx=10, pady=10)
scan_option = tk.StringVar(app)
scan_option.set("Fast Scan")  # Default value
scan_menu = tk.OptionMenu(app, scan_option, *SCAN_OPTIONS.keys())
scan_menu.grid(row=1, column=1, padx=10, pady=10)

scan_button = tk.Button(app, text="Start Scan", command=start_scan, width=20)
scan_button.grid(row=2, column=0, padx=10, pady=10)

save_button = tk.Button(app, text="Save Report", command=lambda: save_to_text(app.report_content), width=20)
save_button.grid(row=2, column=1, padx=10, pady=10)

save_pdf_button = tk.Button(app, text="Save to PDF", command=lambda: save_to_pdf(app.report_content), width=20)
save_pdf_button.grid(row=2, column=2, padx=10, pady=10)

log_text = scrolledtext.ScrolledText(app, width=80, height=20)
log_text.grid(row=3, column=0, columnspan=4, padx=10, pady=10)

# Run the Tkinter main loop
app.mainloop()
